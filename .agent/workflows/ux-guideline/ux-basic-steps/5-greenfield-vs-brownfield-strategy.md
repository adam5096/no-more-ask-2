---
description: [Strategy] 針對不同的專案起點（綠地 vs 棕地），調整 ORCA 工作流的優先權與實作方式
---

### 1. 場景定義與核心差異

在不同的土地上蓋房子，所需的工具與心理準備截然不同：

| 特性 | 綠地開發 (Greenfield) | 棕地開發 (Brownfield) |
| --- | --- | --- |
| **定義** | 從零開始，無歷史包袱。 | 在現有系統、資料庫或 API 上開發。 |
| **ORCA 角色** | **創造者 (Creator)**：定義理想模型。 | **轉譯者 (Translator)**：修復毀損的模型。 |
| **首要任務** | 需求訪談  建模。 | 既存結構稽核  映射與對齊。 |
| **風險** | 架構過度設計 (Over-engineering)。 | 被舊有錯誤邏輯綁架 (Legacy Debt)。 |

---

### 2. 綠地開發工作流：由內而外 (Top-Down)

當你擁有最高自由度時，請嚴格執行 `02-ORCA-Object-Modeling.md` 的標準順序：

1. **純粹建模**：完全根據業務需求定義物件，不考慮資料庫性能或現有 API。
2. **語意對齊**：確保 C# 的 Class Name、資料庫 Table Name 與 Vue 的 Component Name 完全一致。
3. **制定規範**：趁現在建立 `03-Documentation-Standard.md`，防止未來變成混亂的棕地。

---

### 3. 棕地開發工作流：考古與橋接 (Bottom-Up)

當面對舊系統時，ORCA 的順序需要調整為「逆向工程」：

#### 階段 A：既存結構稽核 (Archeology)

* **動作**：從現有的 SQL Schema 或 Swagger API 文件中萃取現有名詞。
* **關鍵提問**：這個 Table 真的代表一個「物件」嗎？還是它只是以前為了省事而建的「假物件」？

#### 階段 B：物件映射 (Mapping & Gap Analysis)

* **動作**：將「理想中的 ORCA 物件」與「現實中的資料表」連線。
* **找缺口**：
* **Missing**：新需求需要的屬性，舊資料庫沒有。
* **Broken**：舊結構將一個物件拆得太散（如：User 屬性散在三個表）。
* **Redundant**：舊系統中無用的廢棄欄位。



#### 階段 C：防腐層設計 (The Anti-Corruption Layer)

這是在棕地中保持優雅的關鍵技術：

* **C# 端 (Adapter Pattern)**：建立一個實體類別來包裝舊有的資料結構，將其轉化為符合新 ORCA 邏輯的物件。
* **Vue 端 (Data Transformer)**：在 API 請求回傳後，先經過一個清洗函數（Transform），將混亂的舊資料格式轉化為乾淨的 Vue Props。

---

### 4. 實作策略選擇表

根據專案現況，選擇你的戰鬥方式：

| 狀況 | 推薦策略 | 執行動作 |
| --- | --- | --- |
| **舊資料庫結構完美** | **直接延伸** | 直接在原有的 Object 上增加 Attributes 或 CTAs。 |
| **舊結構極差，但不能動** | **封裝與轉譯** | 在 C# 使用 `AutoMapper` 或在 Vue 使用 `Composables` 重新定義物件邊界。 |
| **舊系統正準備汰換** | **絞殺者模式 (Strangler)** | 建立全新的綠地物件，並透過 API 逐一取代舊有的功能模組。 |

---

## 💡 專家的小提醒

在**棕地開發**中，最常見的錯誤是「試圖一次修好所有舊結構」。

* **建議：** 每次只修正你這次功能會碰到的物件邊界。
* **前端提醒：** 善用 TypeScript 的 `interface` 來定義你「希望」收到的資料結構，即使後端 API 回傳得很亂，你也要在前端將其對齊。

---
