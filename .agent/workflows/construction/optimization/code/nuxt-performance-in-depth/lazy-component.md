---
description: Nuxt Lazy Component 使用指南
---

#### 1. 核心機制
Nuxt 允許你透過在元件名稱前加上 `Lazy` 前綴（例如 `<LazyAppFooter />`）來自動啟用延遲載入。
*   **原理**：Nuxt 底層會使用 Vue 的 `defineAsyncComponent` 將該元件轉換為動態引入（Dynamic Import）。
*   **效果**：該元件的程式碼**不會**被打包進頁面的主 JavaScript 檔案（entry file）中，而是拆分成獨立的檔案，只有在需要渲染時才會透過 HTTP 請求下載,。

---

#### 2. 適用場景 (Recommended Scenarios)
使用 `Lazy` 的主要目標是**減少初始頁面載入大小 (Initial Bundle Size)**。以下是影片推薦的最佳適用情境：

*   **條件式渲染的互動元件 (v-if)**
    *   **例子**：Modal（彈出視窗）、Drawer（抽屜式選單）、Tooltip。
    *   **原因**：這類元件通常預設是隱藏的（`v-if="false"`）。如果不使用 Lazy，它們的程式碼會被直接打包進主頁面中，即使用者根本沒打開 Modal，也必須下載它的程式碼。使用 Lazy 後，只有當使用者點擊按鈕觸發顯示時，瀏覽器才會下載該元件。
*   **非首屏內容 (Below the Fold)**
    *   **例子**：頁尾 (Footer)、頁面底部的相關推薦區塊。
    *   **原因**：使用者進入頁面時不會立刻看到底部，因此可以延後載入，讓首屏內容更快顯示,。
*   **特定裝置內容**
    *   **例子**：手機版的側邊欄 (Mobile Sidebar)。
    *   **原因**：如果在桌面版不顯示，或者手機版預設隱藏，使用 Lazy 可以避免載入不必要的資源。

---

#### 3. 使用限制與警告 (Restrictions & Warnings)
影片強烈建議**不要**對所有元件都使用 Lazy loading，否則會造成反效果：

*   **避免用於首屏關鍵內容 (Above the Fold)**
    *   **例子**：Header (頁首)、桌面版 Sidebar (側邊欄)、頁面主要內容。
    *   **原因**：這些內容是使用者一進來就必須看到的。如果使用 Lazy，瀏覽器必須先下載主程式，解析後發現需要該元件，才發送第二次請求去下載它，這會導致畫面出現閃爍或顯示延遲，並增加額外的 HTTP 請求,。
*   **避免過度巢狀使用 (The Waterfall Effect)**
    *   **風險**：如果你將父元件設為 Lazy，父元件裡面的子元件也設為 Lazy，孫元件也設為 Lazy...
    *   **後果**：這會導致「瀑布式」的載入延遲。瀏覽器必須下載完父元件 -> 解析 -> 下載子元件 -> 解析 -> 下載孫元件。這會嚴重拖慢使用者看到完整內容的時間。
*   **預取限制 (Prefetching)**
    *   Nuxt 對於頁面路由（Pages）通常會自動預取（Prefetching），但對於手動設定的 Lazy 元件，可能無法自動享受同樣的最佳化機制。

---

#### 4. 效能權衡 (Performance Trade-off)
使用 Lazy loading 是一個交換：
*   **優點**：初始頁面載入變快（下載的 JS 變少）。
*   **缺點**：互動時會有極短暫的延遲（使用者點擊後需要等待幾毫秒下載 JS 才能看到內容）,。

**總結建議 (TL;DR)**：
將 `Lazy` 用於 Modal、Footer 或 `v-if` 隱藏的內容；對於 Header、Sidebar 或首屏可見內容，請使用標準引入。

這份指南是否清楚？如果你手邊有具體的專案結構，我們可以一起看看哪些元件適合加上 `Lazy` 前綴。